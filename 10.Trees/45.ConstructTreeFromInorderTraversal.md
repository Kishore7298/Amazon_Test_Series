## Construct Tree from Preorder Traversal

Construct a binary tree of size N using 2 given arrays pre[] and preLN[]. Array pre[] represents preorder traversal of a binary tree. Array preLN[] has only two possible values ‘L’ and ‘N’. The value ‘L’ in preLN[] indicates that the corresponding node in Binary Tree is a leaf node and value ‘N’ indicates that the corresponding node is a non-leaf node.  
<b>Note: Every node in the binary tree has either 0 or 2 children.</b>

#### Example 1:

```
Input :
N = 5
pre[] = {10, 30, 20, 5, 15}
preLN[] = {N, N, L, L, L}

Output:
          10
        /    \
      30      15
     /  \
   20    5
```

#### Your Task:

You dont need to read input or print anything. Complete the function `constructTree()` which takes N, `pre[]` and `preLN[]` as input parameters and returns the root node of the constructed binary tree.
Note: The output generated by the compiler will contain the inorder traversal of the created binary tree.

Expected Time Complexity: `O(N)`  
Expected Auxiliary Space: `O(N)`

```
Constraints:
1 ≤ N ≤ 10^4
1 ≤ pre[i] ≤ 10^7
preLN[i]: {'N', 'L'}
```

```c++
/*Structure of the Node of the binary tree is as
struct Node
{
	int data;
	struct Node *left;
	struct Node *right;
};
*/

Node* construct(int n, int pre[], char preLN[], int &index) {
    if(index >= n)
        return NULL;

    Node* curr = new Node(pre[index]);

    if(preLN[index++] == 'N') {
        curr->left = construct(n, pre, preLN, index);
        curr->right = construct(n, pre, preLN, index);
    }
    return curr;
}

// function should return the root of the new binary tree formed
Node *constructTree(int n, int pre[], char preLN[]) {
    int index = 0;
    return construct(n, pre, preLN, index);
}
```
